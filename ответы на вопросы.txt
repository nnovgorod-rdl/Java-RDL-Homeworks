1. Обход по коллекциям с помощью стримов и улучшенного цикла  for заметно приятнее глазу нежели обычный цикл for с условиями:
выглядят они проще, их легче читать и понимать.
При этом у стрима есть серьезное преимущество, незаметное на данном примере:
при добавлении дополнительных условий, проверок или действий с элементами коллекции, читаемость кода со стримами если и упадет, то
в меньшей степени, чем у остальных циклов.
Сложнее всего писать обычные циклы, немного проще улучшенный цикл for и легче всего со стримами. Особенно это будет заметно с
множественными проверками/фильтрациями и т.д., потому что в этом случае могут появится вложенные if/else, которые ухудшат читаемость кода.

3. Иногда работа приложения связана с поступлением множества запросов, которые необходимо обработать. Для их обработки используется несколько механизмов:
упрощенная модель - создание потока для каждого запроса (поток-на-запрос); один фоновый поток для запросов и очередь задач; пул потоков.
Первый вариант приводит к созданию потоков, на создание и разрушение которых тратится много ресурсов, при этом это один из самых
простых способов обработки запросов и он хорошо работает с небольшим количеством долгосрочных задач.
Единый фоновый поток хорош в случае обработки низкоприоритетных фоновых задач и когда не важна предсказуемость распределения, при
этом необходимо избегать задач, которые занимают много времени, иначе для их выполнения необходимо создавать новые потоки.
Применение пула потоков могут возникать взаимоблокировки, рассеяние потока и т.д. Тем не менее, пулы потоков решают проблемы
издержек жизненного цикла потоков и пробуксовки ресурсов, к тому же поскольку поток уже существует, когда прибывает запрос,
задержка, произошедшая из-за создания потока, устраняется.

4. Я выбрал для сравнения HashSet и ArrayDeque.  Первая коллекция реализована на основе хеш-таблицы, в случае одинаковых ключей
строит красно-черное дерево в бакете. Вторая коллекция - реализация на основе массива.
Я провел три измерения: добавление миллиона объектов, поиск тысячи объектов и поэлементное удаление всех объектов.
HashSet потратило меньше времени на поиск элементов, во всех остальных случаях результаты были хуже ArrayDeque. Очевидно, что при добавлении элементов
ArrayDeque будет в выигрыше, т.к. он просто добавляет элемент в последнюю пустую ячейку массива, без проверок на уникальность, без вычисления хеша,
время добавления было бы константным, если бы заранее был известен размер массива, а так этой коллекции периодически приходится увеличивать размер
массива, что несколько замедляет быстродействие. HashSet каждый раз вычисляет хешкод, в случае коллизии проверяет методом equals действительно ли
элементы равны друг другу, когда кончаются бакеты приходится пересчитывать хеш всех ранее добавленных элементов, поэтому HashSet ожидаемо медленее.
Поиск элементов быстрее реализован в HashSet, так как, вычислив хешкод, в лучшем случае (при качественной реализации хешфункции) уже известно
местонахождение элемента, в этом случае сложность О(1), ArrayDeque проходит по всем элементам коллекции, начиная с головы если искомый элемент последний,
то сложность O(n).  Удаление элементов из середины списка не поддерживает ни одна из исследуемых коллекций, поэтому я проходился по коллекции с самого
начала и по очереди удалял всеэлементы. HashSet оказалась медленнее, потому что ей нужно сначала вычислить хешкод, в случае коллизии пройти по дереву
внутри бакета. Вывод: в принципе эти коллекции не совсем корректно сравнивать, все-таки HashSet неупорядоченная и хранит только уникальные объекты,
а ArrayDeque упорядоченно и может повторяющиеся, то есть их целесообразно использовать для разных целей. Тем не менее, HashSet имеет смысл использовать,
когда необходимо
